// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	code "github.com/ca-risken/datasource-api/proto/code"

	db "github.com/ca-risken/datasource-api/pkg/db"

	mock "github.com/stretchr/testify/mock"

	model "github.com/ca-risken/datasource-api/pkg/model"
)

// CodeRepoInterface is an autogenerated mock type for the CodeRepoInterface type
type CodeRepoInterface struct {
	mock.Mock
}

// DeleteCodeScanSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteCodeScanSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCodeScanSetting")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteDependencySetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteDependencySetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDependencySetting")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGitHubSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteGitHubSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGitHubSetting")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGitleaksCache provides a mock function with given fields: ctx, githubSettingID
func (_m *CodeRepoInterface) DeleteGitleaksCache(ctx context.Context, githubSettingID uint32) error {
	ret := _m.Called(ctx, githubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGitleaksCache")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) error); ok {
		r0 = rf(ctx, githubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGitleaksSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteGitleaksSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGitleaksSetting")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCodeScanSetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) GetCodeScanSetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*model.CodeCodeScanSetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for GetCodeScanSetting")
	}

	var r0 *model.CodeCodeScanSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeCodeScanSetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeCodeScanSetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeCodeScanSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDependencySetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) GetDependencySetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*model.CodeDependencySetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for GetDependencySetting")
	}

	var r0 *model.CodeDependencySetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeDependencySetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeDependencySetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeDependencySetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGitHubSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) GetGitHubSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) (*model.CodeGitHubSetting, error) {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for GetGitHubSetting")
	}

	var r0 *model.CodeGitHubSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeGitHubSetting, error)); ok {
		return rf(ctx, projectID, GitHubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeGitHubSetting); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitHubSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGitleaksCache provides a mock function with given fields: ctx, projectID, githubSettingID, repositoryFullName, immediately
func (_m *CodeRepoInterface) GetGitleaksCache(ctx context.Context, projectID uint32, githubSettingID uint32, repositoryFullName string, immediately bool) (*model.CodeGitleaksCache, error) {
	ret := _m.Called(ctx, projectID, githubSettingID, repositoryFullName, immediately)

	if len(ret) == 0 {
		panic("no return value specified for GetGitleaksCache")
	}

	var r0 *model.CodeGitleaksCache
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32, string, bool) (*model.CodeGitleaksCache, error)); ok {
		return rf(ctx, projectID, githubSettingID, repositoryFullName, immediately)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32, string, bool) *model.CodeGitleaksCache); ok {
		r0 = rf(ctx, projectID, githubSettingID, repositoryFullName, immediately)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksCache)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32, string, bool) error); ok {
		r1 = rf(ctx, projectID, githubSettingID, repositoryFullName, immediately)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGitleaksSetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) GetGitleaksSetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*model.CodeGitleaksSetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for GetGitleaksSetting")
	}

	var r0 *model.CodeGitleaksSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeGitleaksSetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeGitleaksSetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCodeDataSource provides a mock function with given fields: ctx, codeDataSourceID, name
func (_m *CodeRepoInterface) ListCodeDataSource(ctx context.Context, codeDataSourceID uint32, name string) (*[]model.CodeDataSource, error) {
	ret := _m.Called(ctx, codeDataSourceID, name)

	if len(ret) == 0 {
		panic("no return value specified for ListCodeDataSource")
	}

	var r0 *[]model.CodeDataSource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, string) (*[]model.CodeDataSource, error)); ok {
		return rf(ctx, codeDataSourceID, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, string) *[]model.CodeDataSource); ok {
		r0 = rf(ctx, codeDataSourceID, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeDataSource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, string) error); ok {
		r1 = rf(ctx, codeDataSourceID, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCodeGitHubScanErrorForNotify provides a mock function with given fields: ctx
func (_m *CodeRepoInterface) ListCodeGitHubScanErrorForNotify(ctx context.Context) ([]*db.GitHubScanError, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListCodeGitHubScanErrorForNotify")
	}

	var r0 []*db.GitHubScanError
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*db.GitHubScanError, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*db.GitHubScanError); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*db.GitHubScanError)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCodeScanSetting provides a mock function with given fields: ctx, projectID
func (_m *CodeRepoInterface) ListCodeScanSetting(ctx context.Context, projectID uint32) (*[]model.CodeCodeScanSetting, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for ListCodeScanSetting")
	}

	var r0 *[]model.CodeCodeScanSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*[]model.CodeCodeScanSetting, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *[]model.CodeCodeScanSetting); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeCodeScanSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDependencySetting provides a mock function with given fields: ctx, projectID
func (_m *CodeRepoInterface) ListDependencySetting(ctx context.Context, projectID uint32) (*[]model.CodeDependencySetting, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for ListDependencySetting")
	}

	var r0 *[]model.CodeDependencySetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*[]model.CodeDependencySetting, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *[]model.CodeDependencySetting); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeDependencySetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGitHubSetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) ListGitHubSetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*[]model.CodeGitHubSetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for ListGitHubSetting")
	}

	var r0 *[]model.CodeGitHubSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*[]model.CodeGitHubSetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *[]model.CodeGitHubSetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeGitHubSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGitleaksCache provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) ListGitleaksCache(ctx context.Context, projectID uint32, githubSettingID uint32) (*[]model.CodeGitleaksCache, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	if len(ret) == 0 {
		panic("no return value specified for ListGitleaksCache")
	}

	var r0 *[]model.CodeGitleaksCache
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*[]model.CodeGitleaksCache, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *[]model.CodeGitleaksCache); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeGitleaksCache)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGitleaksSetting provides a mock function with given fields: ctx, projectID
func (_m *CodeRepoInterface) ListGitleaksSetting(ctx context.Context, projectID uint32) (*[]model.CodeGitleaksSetting, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for ListGitleaksSetting")
	}

	var r0 *[]model.CodeGitleaksSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*[]model.CodeGitleaksSetting, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *[]model.CodeGitleaksSetting); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeGitleaksSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCodeCodeScanErrorNotifiedAt provides a mock function with given fields: ctx, errNotifiedAt, codeGithubSettingID, projectID
func (_m *CodeRepoInterface) UpdateCodeCodeScanErrorNotifiedAt(ctx context.Context, errNotifiedAt interface{}, codeGithubSettingID uint32, projectID uint32) error {
	ret := _m.Called(ctx, errNotifiedAt, codeGithubSettingID, projectID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCodeCodeScanErrorNotifiedAt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, uint32, uint32) error); ok {
		r0 = rf(ctx, errNotifiedAt, codeGithubSettingID, projectID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCodeDependencyErrorNotifiedAt provides a mock function with given fields: ctx, errNotifiedAt, codeGithubSettingID, projectID
func (_m *CodeRepoInterface) UpdateCodeDependencyErrorNotifiedAt(ctx context.Context, errNotifiedAt interface{}, codeGithubSettingID uint32, projectID uint32) error {
	ret := _m.Called(ctx, errNotifiedAt, codeGithubSettingID, projectID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCodeDependencyErrorNotifiedAt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, uint32, uint32) error); ok {
		r0 = rf(ctx, errNotifiedAt, codeGithubSettingID, projectID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCodeGitleaksErrorNotifiedAt provides a mock function with given fields: ctx, errNotifiedAt, codeGithubSettingID, projectID
func (_m *CodeRepoInterface) UpdateCodeGitleaksErrorNotifiedAt(ctx context.Context, errNotifiedAt interface{}, codeGithubSettingID uint32, projectID uint32) error {
	ret := _m.Called(ctx, errNotifiedAt, codeGithubSettingID, projectID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCodeGitleaksErrorNotifiedAt")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, uint32, uint32) error); ok {
		r0 = rf(ctx, errNotifiedAt, codeGithubSettingID, projectID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertCodeScanSetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertCodeScanSetting(ctx context.Context, data *code.CodeScanSettingForUpsert) (*model.CodeCodeScanSetting, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for UpsertCodeScanSetting")
	}

	var r0 *model.CodeCodeScanSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.CodeScanSettingForUpsert) (*model.CodeCodeScanSetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.CodeScanSettingForUpsert) *model.CodeCodeScanSetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeCodeScanSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.CodeScanSettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertDependencySetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertDependencySetting(ctx context.Context, data *code.DependencySettingForUpsert) (*model.CodeDependencySetting, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for UpsertDependencySetting")
	}

	var r0 *model.CodeDependencySetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.DependencySettingForUpsert) (*model.CodeDependencySetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.DependencySettingForUpsert) *model.CodeDependencySetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeDependencySetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.DependencySettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertGitHubSetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertGitHubSetting(ctx context.Context, data *code.GitHubSettingForUpsert) (*model.CodeGitHubSetting, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for UpsertGitHubSetting")
	}

	var r0 *model.CodeGitHubSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitHubSettingForUpsert) (*model.CodeGitHubSetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitHubSettingForUpsert) *model.CodeGitHubSetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitHubSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.GitHubSettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertGitleaksCache provides a mock function with given fields: ctx, projectID, data
func (_m *CodeRepoInterface) UpsertGitleaksCache(ctx context.Context, projectID uint32, data *code.GitleaksCacheForUpsert) (*model.CodeGitleaksCache, error) {
	ret := _m.Called(ctx, projectID, data)

	if len(ret) == 0 {
		panic("no return value specified for UpsertGitleaksCache")
	}

	var r0 *model.CodeGitleaksCache
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, *code.GitleaksCacheForUpsert) (*model.CodeGitleaksCache, error)); ok {
		return rf(ctx, projectID, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, *code.GitleaksCacheForUpsert) *model.CodeGitleaksCache); ok {
		r0 = rf(ctx, projectID, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksCache)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, *code.GitleaksCacheForUpsert) error); ok {
		r1 = rf(ctx, projectID, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertGitleaksSetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertGitleaksSetting(ctx context.Context, data *code.GitleaksSettingForUpsert) (*model.CodeGitleaksSetting, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for UpsertGitleaksSetting")
	}

	var r0 *model.CodeGitleaksSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitleaksSettingForUpsert) (*model.CodeGitleaksSetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitleaksSettingForUpsert) *model.CodeGitleaksSetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.GitleaksSettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCodeRepoInterface creates a new instance of CodeRepoInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCodeRepoInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *CodeRepoInterface {
	mock := &CodeRepoInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
