// Code generated by mockery v2.30.1. DO NOT EDIT.

package mocks

import (
	context "context"

	code "github.com/ca-risken/datasource-api/proto/code"

	mock "github.com/stretchr/testify/mock"

	model "github.com/ca-risken/datasource-api/pkg/model"
)

// CodeRepoInterface is an autogenerated mock type for the CodeRepoInterface type
type CodeRepoInterface struct {
	mock.Mock
}

// DeleteDependencySetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteDependencySetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGitHubSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteGitHubSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGitleaksCache provides a mock function with given fields: ctx, githubSettingID
func (_m *CodeRepoInterface) DeleteGitleaksCache(ctx context.Context, githubSettingID uint32) error {
	ret := _m.Called(ctx, githubSettingID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) error); ok {
		r0 = rf(ctx, githubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGitleaksSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) DeleteGitleaksSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) error {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) error); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetDependencySetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) GetDependencySetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*model.CodeDependencySetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	var r0 *model.CodeDependencySetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeDependencySetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeDependencySetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeDependencySetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGitHubSetting provides a mock function with given fields: ctx, projectID, GitHubSettingID
func (_m *CodeRepoInterface) GetGitHubSetting(ctx context.Context, projectID uint32, GitHubSettingID uint32) (*model.CodeGitHubSetting, error) {
	ret := _m.Called(ctx, projectID, GitHubSettingID)

	var r0 *model.CodeGitHubSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeGitHubSetting, error)); ok {
		return rf(ctx, projectID, GitHubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeGitHubSetting); ok {
		r0 = rf(ctx, projectID, GitHubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitHubSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, GitHubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGitleaksCache provides a mock function with given fields: ctx, projectID, githubSettingID, repositoryFullName, immediately
func (_m *CodeRepoInterface) GetGitleaksCache(ctx context.Context, projectID uint32, githubSettingID uint32, repositoryFullName string, immediately bool) (*model.CodeGitleaksCache, error) {
	ret := _m.Called(ctx, projectID, githubSettingID, repositoryFullName, immediately)

	var r0 *model.CodeGitleaksCache
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32, string, bool) (*model.CodeGitleaksCache, error)); ok {
		return rf(ctx, projectID, githubSettingID, repositoryFullName, immediately)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32, string, bool) *model.CodeGitleaksCache); ok {
		r0 = rf(ctx, projectID, githubSettingID, repositoryFullName, immediately)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksCache)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32, string, bool) error); ok {
		r1 = rf(ctx, projectID, githubSettingID, repositoryFullName, immediately)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGitleaksSetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) GetGitleaksSetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*model.CodeGitleaksSetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	var r0 *model.CodeGitleaksSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*model.CodeGitleaksSetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *model.CodeGitleaksSetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCodeDataSource provides a mock function with given fields: ctx, codeDataSourceID, name
func (_m *CodeRepoInterface) ListCodeDataSource(ctx context.Context, codeDataSourceID uint32, name string) (*[]model.CodeDataSource, error) {
	ret := _m.Called(ctx, codeDataSourceID, name)

	var r0 *[]model.CodeDataSource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, string) (*[]model.CodeDataSource, error)); ok {
		return rf(ctx, codeDataSourceID, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, string) *[]model.CodeDataSource); ok {
		r0 = rf(ctx, codeDataSourceID, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeDataSource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, string) error); ok {
		r1 = rf(ctx, codeDataSourceID, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDependencySetting provides a mock function with given fields: ctx, projectID
func (_m *CodeRepoInterface) ListDependencySetting(ctx context.Context, projectID uint32) (*[]model.CodeDependencySetting, error) {
	ret := _m.Called(ctx, projectID)

	var r0 *[]model.CodeDependencySetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*[]model.CodeDependencySetting, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *[]model.CodeDependencySetting); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeDependencySetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGitHubSetting provides a mock function with given fields: ctx, projectID, githubSettingID
func (_m *CodeRepoInterface) ListGitHubSetting(ctx context.Context, projectID uint32, githubSettingID uint32) (*[]model.CodeGitHubSetting, error) {
	ret := _m.Called(ctx, projectID, githubSettingID)

	var r0 *[]model.CodeGitHubSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) (*[]model.CodeGitHubSetting, error)); ok {
		return rf(ctx, projectID, githubSettingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint32) *[]model.CodeGitHubSetting); ok {
		r0 = rf(ctx, projectID, githubSettingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeGitHubSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint32) error); ok {
		r1 = rf(ctx, projectID, githubSettingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGitleaksSetting provides a mock function with given fields: ctx, projectID
func (_m *CodeRepoInterface) ListGitleaksSetting(ctx context.Context, projectID uint32) (*[]model.CodeGitleaksSetting, error) {
	ret := _m.Called(ctx, projectID)

	var r0 *[]model.CodeGitleaksSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (*[]model.CodeGitleaksSetting, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) *[]model.CodeGitleaksSetting); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]model.CodeGitleaksSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertDependencySetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertDependencySetting(ctx context.Context, data *code.DependencySettingForUpsert) (*model.CodeDependencySetting, error) {
	ret := _m.Called(ctx, data)

	var r0 *model.CodeDependencySetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.DependencySettingForUpsert) (*model.CodeDependencySetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.DependencySettingForUpsert) *model.CodeDependencySetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeDependencySetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.DependencySettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertGitHubSetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertGitHubSetting(ctx context.Context, data *code.GitHubSettingForUpsert) (*model.CodeGitHubSetting, error) {
	ret := _m.Called(ctx, data)

	var r0 *model.CodeGitHubSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitHubSettingForUpsert) (*model.CodeGitHubSetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitHubSettingForUpsert) *model.CodeGitHubSetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitHubSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.GitHubSettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertGitleaksCache provides a mock function with given fields: ctx, projectID, data
func (_m *CodeRepoInterface) UpsertGitleaksCache(ctx context.Context, projectID uint32, data *code.GitleaksCacheForUpsert) (*model.CodeGitleaksCache, error) {
	ret := _m.Called(ctx, projectID, data)

	var r0 *model.CodeGitleaksCache
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, *code.GitleaksCacheForUpsert) (*model.CodeGitleaksCache, error)); ok {
		return rf(ctx, projectID, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, *code.GitleaksCacheForUpsert) *model.CodeGitleaksCache); ok {
		r0 = rf(ctx, projectID, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksCache)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, *code.GitleaksCacheForUpsert) error); ok {
		r1 = rf(ctx, projectID, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertGitleaksSetting provides a mock function with given fields: ctx, data
func (_m *CodeRepoInterface) UpsertGitleaksSetting(ctx context.Context, data *code.GitleaksSettingForUpsert) (*model.CodeGitleaksSetting, error) {
	ret := _m.Called(ctx, data)

	var r0 *model.CodeGitleaksSetting
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitleaksSettingForUpsert) (*model.CodeGitleaksSetting, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *code.GitleaksSettingForUpsert) *model.CodeGitleaksSetting); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.CodeGitleaksSetting)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *code.GitleaksSettingForUpsert) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCodeRepoInterface creates a new instance of CodeRepoInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCodeRepoInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *CodeRepoInterface {
	mock := &CodeRepoInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
